name: 'Terraform Plan - Multiple Workspaces'
description: 'Runs a terraform plan for a for a repo with a multiple workspaces (i.e. most terminus repos).'
inputs:
  ssh_key:
    description: '[secret] GitHub SSH Key for pulling repo.'
    required: true
  terraform_version:
    description: '[decimal] (i.e. 1.0.11) Terraform version to use.'
    required: true
  terraform_workspace:
    description: '[string] (i.e. ninja/prod-east) TF Workspace.'
    default: "default"
    required: false
  enable_plan_commenter:
    description: '[bool] (i.e. true/false) Enable the tf plan commenter.'
    required: false
    default: 'true'
  checkout_ref:
    description: 'A checkout-able object. Blank defaults to the Action default behavior'
    required: false
    default: ''
  pre_apply_target:
    description: '[string][advanced][do not use] A targeted resource to have terraform `apply` prior to planning.  USE WITH CAUTION.'
    required: false
    default: ''
  use_beta_commenter:
    description: '[bool] Whether to use the beta version of the PR commenter (see the v2-beta tag on its repo).'
    required: false
    default: 'false'
  enable_tflint:
    description: '[bool] (i.e. true/false) Whether or not to enable and run tflint.'
    required: false
    default: 'true'

runs:
  using: "composite"
  steps:
    - name: Validate Inputs
      env:
        SSH_KEY: ${{ inputs.ssh_key }}
        TERRAFORM_VERSION: ${{ inputs.terraform_version }}
        TERRAFORM_WORKSPACE: ${{ inputs.terraform_workspace }}
      run: |
        cd ${{ github.action_path }}
        source ../../shell-scripts/input-validator.sh

        declare -A inputs
        inputs[ssh_key]="$SSH_KEY"
        inputs[terraform_version]="$TERRAFORM_VERSION"
        inputs[terraform_workspace]="TERRAFORM_WORKSPACE"

        validateInput inputs
      shell: bash
    - name: Install SSH Key
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ inputs.ssh_key }}
    - name: Pull
      uses: actions/checkout@v3
      with:
        ref: ${{ inputs.checkout_ref }}
        lfs: true
    # Adding the below step to allow us to reacquire the eks token after the 15 min timeout
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ env.GH_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ env.GH_AWS_SECRET_KEY }}
        aws-region: us-west-2
    - name: HashiCorp - Setup Terraform
      uses: hashicorp/setup-terraform@v1.2.1
      with:
        terraform_version: ${{ inputs.terraform_version }}
    - name: TF Plan
      id: plan-run
      # have to use /bin/bash because GHA runs by default with `set -e` to end execution on any error.
      # we want to capture the error instead.
      shell: '/bin/bash {0}'
      run: |
        # a lot going on here.  copy the stdout file handle to fd5.
        exec 5>&1

        if [ "${{ inputs.terraform_workspace }}" == "prod" ] || [ "${{ inputs.terraform_workspace }}" == "stage" ] || [ "${{ inputs.terraform_workspace }}" == "qa" ] ; then
          shared_workspace=${{ inputs.terraform_workspace }}
        else
          shared_workspace=default
        fi

        terraform version
        terraform init -lock=false -input=false
        terraform validate
        terraform workspace select ${{ inputs.terraform_workspace }}
        terraform workspace show

        
        # merge stderr into stdout and print it to fd5 (parent shell's stdout); exit with the code from terraform plan
        JSON_OUTPUT=$(terraform plan $(printf -- '-var-file=%s ' vars/$shared_workspace*.tfvars) -lock=false -input=false -json -out=tfplan 2>&1 | tee /dev/fd/5; exit ${PIPESTATUS[0]})
        CHANGE_SUMMARY=$(echo $JSON_OUTPUT | jq -R 'fromjson? | select(type == "object")' | jq -s '.[] | select(.type == "change_summary") | .["@message"]')
        HUMAN_OUTPUT-$(terraform show tfplan)
        # store the exit code here
        EXITCODE=$?

        echo "JSON_OUTPUT=$JSON_OUTPUT" >> $GITHUB_OUTPUT
        echo "CHANGE_SUMMARY=$CHANGE_SUMMARY" >> $GITHUB_OUTPUT
        echo "HUMAN_OUTPUT=$HUMAN_OUTPUT" >> $GITHUB_OUTPUT

        # set exit code for pickup later, and make sure we exit with same code, MIGHT NOT BE NECESSARY???
        echo "::set-output name=exit::${EXITCODE}"
        exit $EXITCODE
    - name: Update PR
      uses: actions/github-script@v6
      id: plan-comment
      with:
        github-token: ${{ env.GITHUB_TOKEN }}
        script: |
          // 1. Retrieve existing bot comments for the PR
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          const botComment = comments.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes('Terraform Plan Output')
          });
          const output = `#### Terraform Plan Output
              <span style="color:green">${{ steps.plan-run.outputs.CHANGE_SUMMARY }}</span>


              <details><summary>Plan Results</summary>
              \`\`\`
              ${{ steps.plan-run.outputs.HUMAN_OUTPUT }}
              \`\`\`
              </details>
              `;
          // 3. Delete previous comment so PR timeline makes sense
          if (botComment) {
            github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
            });
          }
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });
